/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

// Byte per audio sample. (32 bit float)
const BYTES_PER_SAMPLE = Float32Array.BYTES_PER_ELEMENT;

// Basic byte unit of WASM heap. (16 bit = 2 bytes)
const BYTES_PER_UNIT = Uint16Array.BYTES_PER_ELEMENT;

// The max audio channel on Chrome is 32.
const MAX_CHANNEL_COUNT = 32;

// WebAudio's render quantum size.
const RENDER_QUANTUM_FRAMES = 320;
// const RENDER_QUANTUM_FRAMES = 128;


/**
 * A WASM HEAP wrapper for AudioBuffer class. This breaks down the AudioBuffer
 * into an Array of Float32Array for the convinient WASM opearion.
 *
 * @class
 * @dependency Module A WASM module generated by the emscripten glue code.
 */
class HeapAudioBuffer {
  /**
   * @constructor
   * @param  {object} wasmModule WASM module generated by Emscripten.
   * @param  {number} length Buffer frame length.
   * @param  {number} channelCount Number of channels.
   * @param  {number=} maxChannelCount Maximum number of channels.
   */
  constructor(wasmModule, length, channelCount, maxChannelCount) {
    // The |channelCount| must be greater than 0, and less than or equal to
    // the maximum channel count.
    this._isInitialized = false;
    this._module = wasmModule;
    this._length = length;
    this._maxChannelCount = maxChannelCount ?
        Math.min(maxChannelCount, MAX_CHANNEL_COUNT) : channelCount;
    this._channelCount = channelCount;
    this._allocateHeap();
    this._isInitialized = true;
  }

  /**
   * Allocates memory in the WASM heap and set up Float32Array views for the
   * channel data.
   *
   * @private
   */
  _allocateHeap() {
    const channelByteSize = this._length * BYTES_PER_SAMPLE;
    const dataByteSize = this._channelCount * channelByteSize;
    this._dataPtr = this._module._malloc(dataByteSize);
    this._channelData = [];
    for (let i = 0; i < this._channelCount; ++i) {
      const startByteOffset = this._dataPtr + i * channelByteSize;
      const endByteOffset = startByteOffset + channelByteSize;
      // Get the actual array index by dividing the byte offset by 2 bytes.
      this._channelData[i] =
          this._module.HEAPF32.subarray(
              startByteOffset >> BYTES_PER_UNIT,
              endByteOffset >> BYTES_PER_UNIT);
    }
  }

  /**
   * Adapt the current channel count to the new input buffer.
   *
   * @param  {number} newChannelCount The new channel count.
   */
  adaptChannel(newChannelCount) {
    if (newChannelCount < this._maxChannelCount) {
      this._channelCount = newChannelCount;
    }
  }

  /**
   * Getter for the buffer length in frames.
   *
   * @return {?number} Buffer length in frames.
   */
  get length() {
    return this._isInitialized ? this._length : null;
  }

  /**
   * Getter for the number of channels.
   *
   * @return {?number} Buffer length in frames.
   */
  get numberOfChannels() {
    return this._isInitialized ? this._channelCount : null;
  }

  /**
   * Getter for the maxixmum number of channels allowed for the instance.
   *
   * @return {?number} Buffer length in frames.
   */
  get maxChannelCount() {
    return this._isInitialized ? this._maxChannelCount : null;
  }

  /**
   * Returns a Float32Array object for a given channel index. If the channel
   * index is undefined, it returns the reference to the entire array of channel
   * data.
   *
   * @param  {number|undefined} channelIndex Channel index.
   * @return {?Array} a channel data array or an
   * array of channel data.
   */
  getChannelData(channelIndex) {
    if (channelIndex >= this._channelCount) {
      return null;
    }

    return typeof channelIndex === 'undefined' ?
        this._channelData : this._channelData[channelIndex];
  }

  /**
   * Returns the base address of the allocated memory space in the WASM heap.
   *
   * @return {number} WASM Heap address.
   */
  getHeapAddress() {
    return this._dataPtr;
  }

  /**
   * Returns the base address of the allocated memory space in the WASM heap.
   *
   * @return {number} WASM Heap address.
   */
  getPointer() {
    return this._dataPtr;
  }

  /**
   * Frees the allocated memory space in the WASM heap.
   */
  free() {
    this._isInitialized = false;
    this._module._free(this._dataPtr);
    this._module._free(this._pointerArrayPtr);
    this._channelData = null;
  }
} // class HeapAudioBuffer


/**
 * A JS FIFO implementation for the AudioWorklet. 3 assumptions for the
 * simpler operation:
 *  1. the push and the pull operation are done by 128 frames. (Web Audio
 *    API's render quantum size in the speficiation)
 *  2. the channel count of input/output cannot be changed dynamically.
 *    The AudioWorkletNode should be configured with the `.channelCount = k`
 *    (where k is the channel count you want) and
 *    `.channelCountMode = explicit`.
 *  3. This is for the single-thread operation. (obviously)
 *
 * @class
 */
class RingBuffer {
  /**
   * @constructor
   * @param  {number} length Buffer length in frames.
   * @param  {number} channelCount Buffer channel count.
   */
  constructor(length, channelCount) {
    this._readIndex = 0;
    this._writeIndex = 0;
    this._framesAvailable = 0;

    this._channelCount = channelCount;
    this._length = length;
    this._channelData = [];
    for (let i = 0; i < this._channelCount; ++i) {
      this._channelData[i] = new Float32Array(length);
    }
  }

  /**
   * Getter for Available frames in buffer.
   *
   * @return {number} Available frames in buffer.
   */
  get framesAvailable() {
    return this._framesAvailable;
  }

  // /**
  //  * Push a sequence of Float32Arrays to buffer.
  //  *
  //  * @param  {array} arraySequence A sequence of Float32Arrays.
  //  */
  // push(arraySequence) {
  //   // The channel count of arraySequence and the length of each channel must
  //   // match with this buffer obejct.

  //   // Transfer data from the |arraySequence| storage to the internal buffer.
  //   if (arraySequence && arraySequence[0]) {
  //     const sourceLength = arraySequence[0].length;
  //     for (let i = 0; i < sourceLength; ++i) {
  //       const writeIndex = (this._writeIndex + i) % this._length;
  //       for (let channel = 0; channel < this._channelCount; ++channel) {
  //         this._channelData[channel][writeIndex] = arraySequence[channel] ? arraySequence[channel][i] : 0;
  //       }
  //     }

  //     this._writeIndex += sourceLength;
  //     if (this._writeIndex >= this._length) {
  //       this._writeIndex = 0;
  //     }

  //     // For excessive frames, the buffer will be overwritten.
  //     this._framesAvailable += sourceLength;
  //     if (this._framesAvailable > this._length) {
  //       this._framesAvailable = this._length;
  //     }
  //   }
  // }

  // /**
  //  * Pull data out of buffer and fill a given sequence of Float32Arrays.
  //  *
  //  * @param  {array} arraySequence An array of Float32Arrays.
  //  */
  // pull(arraySequence) {
  //   // The channel count of arraySequence and the length of each channel must
  //   // match with this buffer obejct.

  //   // If the FIFO is completely empty, do nothing.
  //   // if (this._framesAvailable === 0) {
  //   //   return;
  //   // }


  //    // Если данных нет — обнуляем выход
  //   if (this._framesAvailable === 0) {
  //     if (!arraySequence || !arraySequence[0]) return;
  //     const frames = arraySequence[0].length;
  //     for (let ch = 0; ch < arraySequence.length; ch++) {
  //       arraySequence[ch].fill(0);
  //     }
  //     return;
  //   }

  //   const frames = arraySequence[0].length;
  //   for (let i = 0; i < frames; i++) {
  //     const readIndex = (this._readIndex + i) % this._length;
  //     for (let ch = 0; ch < arraySequence.length; ch++) {
  //       arraySequence[ch][i] = this._channelData[ch][readIndex];
  //     }
  //   }

  //   this._readIndex = (this._readIndex + frames) % this._length;
  //   this._framesAvailable = Math.max(0, this._framesAvailable - frames);








  //   // const destinationLength = arraySequence[0].length;

  //   // // Transfer data from the internal buffer to the |arraySequence| storage.
  //   // for (let i = 0; i < destinationLength; ++i) {
  //   //   const readIndex = (this._readIndex + i) % this._length;
  //   //   for (let channel = 0; channel < Math.min(arraySequence.length, this._channelCount); ++channel) {
  //   //     arraySequence[channel][i] = this._channelData[channel][readIndex];
  //   //   }
  //   // }

  //   // this._readIndex += destinationLength;
  //   // if (this._readIndex >= this._length) {
  //   //   this._readIndex = 0;
  //   // }

  //   // this._framesAvailable -= destinationLength;
  //   // if (this._framesAvailable < 0) {
  //   //   this._framesAvailable = 0;
  //   // }
  // }

  clear() {
    this._readIndex = 0;
    this._writeIndex = 0;
    this._framesAvailable = 0;
    for (let ch = 0; ch < this._channelCount; ch++) {
      this._channelData[ch].fill(0);
    }
  }

  push(arraySequence) {
    if (!arraySequence || !arraySequence[0]) return;
    const sourceLength = arraySequence[0].length;
    const len = this._length;
    const channels = this._channelCount;

    if (sourceLength === 0) return;

    // Сколько реально свободно
    const free = len - this._framesAvailable;
    if (free <= 0) {
      // Нет места — пропускаем (или можно перезаписать по необходимости)
      return;
    }

    // Пишем только то, что влезет
    const toCopy = Math.min(sourceLength, free);
    const writeIndex = this._writeIndex;

    const firstChunk = Math.min(toCopy, len - writeIndex);
    const secondChunk = toCopy - firstChunk;

    for (let ch = 0; ch < channels; ch++) {
      const src = arraySequence[ch];
      if (!src) continue;

      this._channelData[ch].set(src.subarray(0, firstChunk), writeIndex);
      if (secondChunk > 0) {
        this._channelData[ch].set(src.subarray(firstChunk, firstChunk + secondChunk), 0);
      }
    }

    this._writeIndex = (writeIndex + toCopy) % len;
    this._framesAvailable += toCopy;

    if (this._writeIndex < 0 || this._writeIndex >= this._length) {
      console.warn('[RingBuffer] writeIndex out of range', this._writeIndex);
    }
  }

  pull(arraySequence) {
    if (!arraySequence || !arraySequence[0]) return;
    const frames = arraySequence[0].length;

    if (this._framesAvailable === 0) {
      for (let ch = 0; ch < arraySequence.length; ch++) {
        arraySequence[ch].fill(0);
      }
      return;
    }

    const toRead = Math.min(frames, this._framesAvailable);
    const len = this._length;
    const readIndex = this._readIndex;

    const firstChunk = Math.min(toRead, len - readIndex);
    const secondChunk = toRead - firstChunk;

    for (let ch = 0; ch < arraySequence.length; ch++) {
      const dest = arraySequence[ch];
      const buf = this._channelData[ch];
      dest.set(buf.subarray(readIndex, readIndex + firstChunk), 0);
      if (secondChunk > 0) {
        dest.set(buf.subarray(0, secondChunk), firstChunk);
      }
      // если данных меньше чем frames — заполняем остаток нулями
      if (toRead < frames) dest.fill(0, toRead);
    }

    this._readIndex = (readIndex + toRead) % len;
    this._framesAvailable -= toRead;

    if (this._readIndex < 0 || this._readIndex >= this._length) {
      console.warn('[RingBuffer] readIndex out of range', this._readIndex);
    }
  }


  
} // class RingBuffer


export {
  MAX_CHANNEL_COUNT,
  RENDER_QUANTUM_FRAMES,
  HeapAudioBuffer,
  RingBuffer,
};